"""
Gemini Image Generation Tools for Interior Design Crew.

Uses Google's Gemini API (Gemini 2.5 Flash with image generation)
for room redesign and interior visualization.

API Reference: https://ai.google.dev/gemini-api/docs/image-generation
"""

import os
import json
import base64
import requests
from typing import Optional, Dict, Any
from crewai.tools import tool


# Environment variables
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
GEMINI_MODEL = os.getenv("GEMINI_IMAGE_MODEL", "gemini-2.0-flash-exp")


def _get_gemini_headers() -> Dict[str, str]:
    """Get headers for Gemini API requests."""
    if not GOOGLE_API_KEY:
        raise ValueError("GOOGLE_API_KEY environment variable not set")
    return {
        "Content-Type": "application/json",
    }


def _download_image_as_base64(image_url: str) -> Optional[str]:
    """Download an image from URL and convert to base64."""
    try:
        response = requests.get(image_url, timeout=30)
        response.raise_for_status()
        return base64.b64encode(response.content).decode("utf-8")
    except Exception as e:
        return None


def _get_mime_type(image_url: str) -> str:
    """Determine MIME type from URL or default to JPEG."""
    lower_url = image_url.lower()
    if ".png" in lower_url:
        return "image/png"
    elif ".webp" in lower_url:
        return "image/webp"
    elif ".gif" in lower_url:
        return "image/gif"
    return "image/jpeg"


@tool("Redesign Room Image")
def redesign_room_image(
    image_url: str,
    style_prompt: str,
    property_id: str,
    room_type: Optional[str] = None
) -> str:
    """
    Redesign a room image using Gemini's image generation capabilities.
    
    Use this tool to transform property listing photos into redesigned
    interior visualizations based on a specified style.
    
    Args:
        image_url: URL of the original room image to redesign
        style_prompt: Description of desired style (e.g., "modern minimalist with 
                      gray walls, large TV, plush rug, and indoor plants")
        property_id: Unique identifier for the property
        room_type: Optional room type (e.g., "living room", "bedroom", "kitchen")
    
    Returns:
        JSON string with success status and redesigned image data (base64)
    """
    try:
        if not GOOGLE_API_KEY:
            return json.dumps({
                "success": False,
                "error": "GOOGLE_API_KEY environment variable not set",
                "property_id": property_id
            })
        
        # Download the original image
        image_base64 = _download_image_as_base64(image_url)
        if not image_base64:
            return json.dumps({
                "success": False,
                "error": f"Failed to download image from URL: {image_url}",
                "property_id": property_id
            })
        
        mime_type = _get_mime_type(image_url)
        
        # Build the prompt
        room_context = f"This is a {room_type}. " if room_type else ""
        full_prompt = (
            f"{room_context}Transform this room into a beautifully redesigned interior. "
            f"Style requirements: {style_prompt}. "
            "Keep the same room dimensions and perspective. "
            "Make it look realistic and professionally designed."
        )
        
        # Gemini API request
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{GEMINI_MODEL}:generateContent?key={GOOGLE_API_KEY}"
        
        payload = {
            "contents": [
                {
                    "parts": [
                        {
                            "inline_data": {
                                "mime_type": mime_type,
                                "data": image_base64
                            }
                        },
                        {
                            "text": full_prompt
                        }
                    ]
                }
            ],
            "generationConfig": {
                "responseModalities": ["TEXT", "IMAGE"],
                "temperature": 0.7
            }
        }
        
        response = requests.post(url, headers=_get_gemini_headers(), json=payload, timeout=120)
        response.raise_for_status()
        result = response.json()
        
        # Extract generated image from response
        candidates = result.get("candidates", [])
        if not candidates:
            return json.dumps({
                "success": False,
                "error": "No response generated by Gemini",
                "property_id": property_id
            })
        
        parts = candidates[0].get("content", {}).get("parts", [])
        
        generated_image_base64 = None
        description = None
        
        for part in parts:
            if "inline_data" in part:
                generated_image_base64 = part["inline_data"].get("data")
            elif "text" in part:
                description = part["text"]
        
        if not generated_image_base64:
            # If no image generated, return description/error
            return json.dumps({
                "success": False,
                "error": "Gemini did not generate an image",
                "description": description,
                "property_id": property_id
            })
        
        return json.dumps({
            "success": True,
            "property_id": property_id,
            "original_image_url": image_url,
            "room_type": room_type,
            "style_applied": style_prompt,
            "redesigned_image_base64": generated_image_base64,
            "description": description,
            "message": "Room successfully redesigned"
        })
        
    except requests.exceptions.HTTPError as e:
        error_detail = ""
        try:
            error_detail = e.response.json()
        except:
            error_detail = str(e)
        return json.dumps({
            "success": False,
            "error": f"Gemini API error: {error_detail}",
            "property_id": property_id
        })
    except Exception as e:
        return json.dumps({
            "success": False,
            "error": str(e),
            "property_id": property_id
        })


@tool("Generate Room Description")
def generate_room_description(
    image_url: str,
    property_id: str
) -> str:
    """
    Analyze a room image and generate a detailed description of its current state.
    
    Use this tool to understand the current room layout, style, and furniture
    before generating redesign suggestions.
    
    Args:
        image_url: URL of the room image to analyze
        property_id: Unique identifier for the property
    
    Returns:
        JSON string with room analysis including type, style, furniture, and suggestions
    """
    try:
        if not GOOGLE_API_KEY:
            return json.dumps({
                "success": False,
                "error": "GOOGLE_API_KEY environment variable not set",
                "property_id": property_id
            })
        
        # Download the image
        image_base64 = _download_image_as_base64(image_url)
        if not image_base64:
            return json.dumps({
                "success": False,
                "error": f"Failed to download image from URL: {image_url}",
                "property_id": property_id
            })
        
        mime_type = _get_mime_type(image_url)
        
        prompt = """Analyze this room image and provide a detailed JSON response with:
{
    "room_type": "living room/bedroom/kitchen/bathroom/etc",
    "current_style": "description of current interior style",
    "furniture_present": ["list", "of", "furniture"],
    "color_palette": ["main", "colors", "visible"],
    "lighting": "description of lighting conditions",
    "condition": "excellent/good/needs_improvement/poor",
    "redesign_suggestions": [
        "suggestion 1",
        "suggestion 2",
        "suggestion 3"
    ]
}
Only respond with valid JSON, no markdown formatting."""
        
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{GEMINI_MODEL}:generateContent?key={GOOGLE_API_KEY}"
        
        payload = {
            "contents": [
                {
                    "parts": [
                        {
                            "inline_data": {
                                "mime_type": mime_type,
                                "data": image_base64
                            }
                        },
                        {
                            "text": prompt
                        }
                    ]
                }
            ],
            "generationConfig": {
                "temperature": 0.3
            }
        }
        
        response = requests.post(url, headers=_get_gemini_headers(), json=payload, timeout=60)
        response.raise_for_status()
        result = response.json()
        
        candidates = result.get("candidates", [])
        if not candidates:
            return json.dumps({
                "success": False,
                "error": "No response generated",
                "property_id": property_id
            })
        
        text_response = ""
        parts = candidates[0].get("content", {}).get("parts", [])
        for part in parts:
            if "text" in part:
                text_response = part["text"]
                break
        
        # Try to parse the JSON response
        try:
            # Clean up potential markdown formatting
            clean_text = text_response.strip()
            if clean_text.startswith("```"):
                clean_text = clean_text.split("```")[1]
                if clean_text.startswith("json"):
                    clean_text = clean_text[4:]
            clean_text = clean_text.strip()
            
            room_analysis = json.loads(clean_text)
            room_analysis["success"] = True
            room_analysis["property_id"] = property_id
            room_analysis["image_url"] = image_url
            return json.dumps(room_analysis)
        except json.JSONDecodeError:
            return json.dumps({
                "success": True,
                "property_id": property_id,
                "image_url": image_url,
                "raw_analysis": text_response
            })
        
    except Exception as e:
        return json.dumps({
            "success": False,
            "error": str(e),
            "property_id": property_id
        })


@tool("Suggest Design Styles")
def suggest_design_styles(
    room_type: str,
    user_preferences: Optional[str] = None
) -> str:
    """
    Generate interior design style suggestions for a room type.
    
    Use this tool to get style recommendations that can be used
    as prompts for the redesign_room_image tool.
    
    Args:
        room_type: Type of room (e.g., "living room", "bedroom", "kitchen")
        user_preferences: Optional user preferences (e.g., "modern", "cozy", "colorful")
    
    Returns:
        JSON string with list of style suggestions and their descriptions
    """
    # Predefined style templates by room type
    styles = {
        "living room": [
            {
                "name": "Modern Minimalist",
                "prompt": "modern minimalist design with clean lines, neutral colors, low-profile furniture, large sectional sofa, abstract art, and subtle accent lighting"
            },
            {
                "name": "Cozy Scandinavian",
                "prompt": "Scandinavian hygge style with warm wood tones, soft textiles, sheepskin throws, candles, indoor plants, and natural light"
            },
            {
                "name": "Industrial Loft",
                "prompt": "industrial loft style with exposed brick, metal accents, leather furniture, Edison bulbs, and vintage decor"
            },
            {
                "name": "Bohemian Eclectic",
                "prompt": "bohemian eclectic with layered textiles, moroccan poufs, macrame, houseplants, and colorful patterns"
            }
        ],
        "bedroom": [
            {
                "name": "Serene Sanctuary",
                "prompt": "serene bedroom sanctuary with soft neutral palette, platform bed, ambient lighting, blackout curtains, and minimal clutter"
            },
            {
                "name": "Luxurious Hotel",
                "prompt": "luxury hotel style bedroom with tufted headboard, crisp white linens, bedside lamps, plush carpet, and elegant artwork"
            },
            {
                "name": "Japandi Zen",
                "prompt": "Japandi zen bedroom with low bed frame, shoji screens, natural materials, bonsai plants, and warm wood accents"
            }
        ],
        "kitchen": [
            {
                "name": "Modern Chef's Kitchen",
                "prompt": "modern chef's kitchen with waterfall countertops, stainless appliances, pendant lights, breakfast bar, and smart storage"
            },
            {
                "name": "Farmhouse Charm",
                "prompt": "farmhouse kitchen with shaker cabinets, apron sink, butcher block island, open shelving, and vintage accessories"
            },
            {
                "name": "Sleek Contemporary",
                "prompt": "sleek contemporary kitchen with handleless cabinets, integrated appliances, quartz counters, and under-cabinet lighting"
            }
        ],
        "bathroom": [
            {
                "name": "Spa Retreat",
                "prompt": "spa-like bathroom retreat with freestanding tub, rain shower, natural stone, eucalyptus plants, and warm lighting"
            },
            {
                "name": "Modern Luxury",
                "prompt": "modern luxury bathroom with floating vanity, backlit mirror, marble tiles, matte black fixtures, and heated floors"
            }
        ]
    }
    
    room_key = room_type.lower()
    matched_styles = styles.get(room_key, styles.get("living room", []))
    
    # Filter by user preferences if provided
    if user_preferences:
        prefs_lower = user_preferences.lower()
        filtered = [s for s in matched_styles if prefs_lower in s["name"].lower() or prefs_lower in s["prompt"].lower()]
        if filtered:
            matched_styles = filtered
    
    return json.dumps({
        "success": True,
        "room_type": room_type,
        "user_preferences": user_preferences,
        "style_suggestions": matched_styles
    })
